<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux和网络</title>
    <url>/2020/04/18/Linux%E5%92%8C%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p><strong>TCP与HTTP</strong></p>
<ol>
<li><p>HTTPS的加密方式是什么，讲讲整个加密解密流程。<br> 1.客户端（通常是浏览器）先向服务器发出加密通信的请求，发送协议版本，客户端生成随机数，加密方法等等<br> 2.服务端收到请求后回应，内容包含协议版本、服务端生成的随机数、加密方式、服务器证书<br> 3.客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>  如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。<br>   (1) 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br>   (2) 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>   (3) 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。<br> 4.服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。<br>   (1)编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>   (2)服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p>
   <a id="more"></a></li>
<li><p>http1.0和http1.1有什么区别。</p>
</li>
<li><p>TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。<br> 三次握手</p>
<pre><code>1.客户端将SYN位置设为1，随机产生一个值，并将数据包发给服务端，服务端进入等待状态
2.服务端向服务端发送请求，并进入等待接受状态
3.客户端回应客户端收到请求，然后开始通信</code></pre><p> 四次挥手</p>
<pre><code>因为TCP/IP协议是全双工通信
 1.第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
 2.第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
 3.第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
 4.第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</code></pre></li>
<li><p>TIME_WAIT和CLOSE_WAIT的区别。<br>  CLOSE_WAIT是服务端<br>  TIME_WAIT是客户端</p>
</li>
<li><p>说说你知道的几种HTTP响应码，比如200, 302, 404。</p>
</li>
<li><p>当你用浏览器打开一个链接（如：<a href="http://www.javastack.cn/" target="_blank" rel="noopener">http://www.javastack.cn</a>）的时候，计算机做了哪些工作步骤。<br>   1.DNS解析<br>   2.TCP连接<br>   3.发送HTTP请求<br>   4.服务器处理请求并返回HTTP报文<br>   5.浏览器解析渲染页面<br>   6.连接结束</p>
</li>
<li><p>TCP/IP如何保证可靠性，说说TCP头的结构。</p>
</li>
<li><p>如何避免浏览器缓存。</p>
</li>
<li><p>如何理解HTTP协议的无状态性。<br> 无状态是指协议对于事务处理没有记忆能力，服务端不知道客户端什么状态</p>
</li>
<li><p>简述Http请求get和post的区别以及数据包格式。</p>
</li>
<li><p>HTTP有哪些method</p>
</li>
<li><p>简述HTTP请求的报文格式。</p>
</li>
<li><p>HTTP的长连接是什么意思。<br> 长连接就是客户端和服务端的TCP连接不会关闭</p>
</li>
<li><p>Http和https的三次握手有什么区别。</p>
</li>
</ol>
<p>http状态码：200成功，303重定向 304   没有找到方法    403Forbidden 404 未找到页面 500 系统异常    502Bad Gateway  503  服务不可用</p>
<ol start="15">
<li>什么是分块传送。</li>
<li>Session和cookie的区别。<br> 1.存取方式的不同  <pre><code>Cookie中只能保管ASCII字符串，
Session中能够存取任何类型的数据</code></pre> 2.隐私策略的不同<pre><code>Cookie存储在客户端阅读器中，对客户端是可见的，
Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</code></pre>3.服务器压力的不同<br>   Session存储在服务器上，请求量大会比较耗费内存<br>   Cookie保管在客户端，不占用服务器资源。<br>4.跨域支持上的不同<br>   Cookie支持跨域名访问<br>   Session仅在他所在的域名内有效。</li>
<li>v                          </li>
</ol>
<p>19.应用层—表示层—-会话层—–传输层—–网络层——数据链路层——-物理层</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式消息</title>
    <url>/2020/04/18/%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p><strong>消息队列</strong></p>
<p>1.使用过哪些MQ？和其他mq比较有什么优缺点?<br>    activeMQ和RocketMQ<br>2.消息队列的使用场景<br>  1.异步化2.应用解耦<br>3.消息的重发,补充策略<br>    消息重发指的是borker发送给消费者，但消费者处理失败，borker会去重发消息,超过设定次数，lister消费者会给borker发送一个毒ACK消息，borker将该消息放入死信队列中<br>    默认是6次，<br>    重发时间间隔,默认为1s<br>    重投延时<br>  重发需要有幂等性考虑<br>  <a id="more"></a><br>4.如何保证消息的有序性<br>    在MQ中创建多条QUEUE,针对同一规则的数据放入相同队列，比如订单(下单，支付，)，把相同订单号的放入一个队列中，后端消费者消费就行了，<br>    这种可能会有消息重复问题<br>5.消息重复问题<br>    1.保证业务的幂等性(需要在消费段做)<br>    2.保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</p>
<p>5.MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。</p>
<p>6.MQ系统的数据如何保证不丢失<br>   消息丢失场景：<br>      1.生产者消息丢失<br>          1.消息确认模式，分配唯一的ID，只有队列写成功了，回传一个确认的ACK<br>          2.开启一个事务，没有被消费者消费，就事务回滚<br>      2.消息队列消息丢失<br>          1.数据持久化<br>          2.消费完成确认后再删除消息<br>      3.消费端消息丢失<br>          消息丢失，未收到确认的ACK，就重发一次，但是做幂等性处理</p>
<p>7.MQ消息如何做到幂等<br>       1.消息队列分配无关业务、全局唯一的ID<br>       2.业务上自己做消息幂等性<br>8.MQ的消息延迟了怎么处理，</p>
<p>9.利用mq怎么实现最终一致性<br>    1.保证消息不丢失<br>    2.保证消息能被消费正常处理<br>    3.由数据库来做最终的一致性保证</p>
<p>10.如何保证消息队列是高可用的<br>   多种Master/slave模式的集群<br>    1.Shared Nothing Master/Slave  master收到消息同步完slave才响应ACK<br>    2.Shared Database Master/Slave master和slave数据共享，然后数据库的排他锁来竞争，谁拿到锁，谁是master<br>    3.Shared File system Master/Slave   共享文件锁<br>    4.Replicated LevelDB Store   利用zookeer来选举</p>
<p>11.消息可以设置过期时间么，过期了你们一般怎么处理<br>    消息可以设置过期时间，一般过期后会被放入死信队列<br>    死信处理策略：<br>       1.不使用默认死信队列，不便于管理<br>       2.持久化消息不放入死信队列<br>       3.非持久化消息放入<br>       4.过期消息不保存到死信队列<br>       5.丢弃所有死信<br>       6.丢弃指定死信<br>       7.丢弃正则死信</p>
<p>12.MQ消息积压问题<br>     一般MQ消息积压是因为消费者这边出了问题，所以思路是：<br>          1.先解决消费者的问题，让其能正常消费<br>          2.提升消费者的消费能力，紧急扩容<br>          3.假如队列满了，就粗暴一点，临时写程序来介入数据消费，写完就丢掉消息<br>15.MQ的技术选型<br>    ActiveMQ<br>      优点:Java开发，相对简单，功能比较完备<br>      缺点:社区不活跃<br>    RocketMQ<br>       优点:社区活跃，大公司里技术支持，功能完备，经得起考验<br>       缺点：<br>    RabbitMQ<br>        优点:<br>        缺点：erlang语言比较少，出问题了不好处理<br>JMS—–&gt;ActiveMq<br>AMQP—–&gt;RockerMQ</p>
<p>1.JMS<br>  JMS是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<br>2.JMS消息模型<br>   点对点和发布订阅<br>3.MOM 就是面向消息中间件（Message-oriented middleware），是用于以分布式应用或系统中的异步、松耦合、可靠、可扩展和安全通信的一类软件。MOM 的总体思想是它作为消息发送器和消息接收器之间的消息中介,这种中介提供了一个全新水平的松耦合。<br>4.AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准,为面向消息的中间件设计<br>ActiveMq相关知识<br>  1.ActiveMq流程<br>     生产者工作流程:<br>       1.创建连接工厂：ConnectionFactory factory = new ActiveMQConnectionFactory(userName,password,url)<br>       2.创建连接：Connection conn= factory.createConnection();<br>       3.打开连接：conn.start()<br>       4.创建会话并设置会话级别：Session session = conn.createSession(true,Session.SESSION_TRANSACTED);<br>       5.创建消息队列：Queue queue = session.createQueue(name);<br>       6.创建或者获取生产者：MessageProducer produer = session.createProducer(queue);<br>       7.生成者发送消息：producer.send();<br>       8.提交会话事务：session.commit();<br>      消费者工作流程:<br>          1.创建连接工厂：ConnectionFactory factory = new ActiveMQConnectionFactory(userName,password,url)<br>          2.创建连接：Connection conn= factory.createConnection();<br>          3.开始连接：conn.start()<br>          4.创建会话并设置会话级别：Session session = conn.createSession(true,Session.SESSION_TRANSACTED);<br>          5.创建消息队列：Queue queue = session.createQueue(name);<br>          6.创建或者获取生产者：MessageProducer produer = session.createProducer(queue);<br>          7.生成者发送消息：producer.send();<br>          8.提交会话事务：session.commit();</p>
<p>  2.消息存储方式<br>     1.KahaDB存储(默认方式)<br>         KahaDB的存储原理：<br>           在data/kahadb这个目录下，会生成四个文件：<br>               Ø db.data 它是消息的索引文件，本质上是B-Tree（B树），使用B-Tree作为索引指向db-.log里面存储的消息<br>               Ø db.redo 用来进行消息恢复<br>               Ø db-.log 存储消息内容。新的数据以APPEND的方式追加到日志文件末尾。属于顺序写入，因此消息存储是比较快的。默认是32M，达到阀值会自动递增<br>               Ø lock文件 锁，表示当前获得kahadb读写权限的broker<br>     2.JDBC存储<br>     3.内存<br>  3. 支持同步、异步两种发送模式将消息发送到broker上，<br>         同步会要求broker给一个响应，因为是阻塞操作，会影响到客户端<br>         异步发送者不需要等待broker提供反馈，所以性能相对较高。但是可能会出现消息丢失的情况。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存</title>
    <url>/2020/04/18/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p><strong>缓存</strong><br>1.Redis的数据结构都有哪些。<br>  String  hash  list  set soreSet<br>2.如何防止缓存穿透、雪崩和击穿。<br>  缓存穿透:1.布隆过滤器(存在误杀) 2.存储空null，但存活时间很短5分钟<br>  缓存雪崩:1.将失效过期时间随机性分布<br>  缓存击穿:采用互斥锁或者分布式锁来处理<br>  穿透和击穿的区别在于:穿透对于大量key，而击穿针对的是单key<br>  <a id="more"></a><br>3.缓存数据过期后的更新如何设计。<br>  1.请求来的时候，先读缓存，保存一个空key，然后再去读数据库，如果数据库有，再写回到缓存上<br>4.如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。<br>   1.数据先落库，再删除缓存<br>   2.请求来的时候，先读缓存，如果缓存没有，然后再去读数据库，如果数据库有，再写回到缓存上<br>   但是需要注意的是，缓存的穿透和、雪崩、击穿等问题<br>5.Redis的使用要注意什么，内存设置<br>   1.注意建表规范<br>   2.存储数据，设计k-v时候注意可读性，避免大value等<br>   内存设置：<br>     1.通过info命令来查看<br>     2.最好设置max memory 不要超过机器最大内存<br>7.当前redis集群有哪些玩法，各自优缺点，场景。<br>   1.官方的cluser方案；<br>       提出了槽(slot)的概念，16384个，对于Redis的键值对进行散列，分配到这些槽中的一个，然后用节点对应着每一个槽，官方推荐将节点配置成主从，假如主节点失效，通过选举算法会从salve中选出来一个，完全去中心化，配置比较简单，但是出来较晚，使用者不是很多<br>   2.codis；</p>
<p>   3.哨兵；</p>
<p>8.Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。<br>   key 并发写的问题，<br>   1.可以使用乐观锁来处理<br>   2.使用分布式锁来处理<br>9.Redis的选举算法和流程是怎样的。<br>      Raft协议，通过心跳和选举算法实现哨兵， 主观失效和客观失效，<br>10.redis的持久化的机制，aof和rdb的区别。<br>    RDB 就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；<br>       通过bgSave命令触发，从主进程fork()一个子进程来，生成父进程内存中数据快照，然后再替换原文件，  fork会阻塞父进程<br>       优点:1.二进制文件，适合全量备份<br>            2.执行速度比AOF要快<br>        缺点：<br>            1.新老版本的RDB文件不一定兼容<br>            ２.没法做到秒级<br>            ３.fork属于重量操作，不能轻易操作<br>    AOF  持久化记录服务器执行的所有写操作命令<br>        1.将写命令写道缓冲区<br>        2.AOF缓冲区将根据相关策略向磁盘上同步<br>        3.因为AOF文件会越变越大，需要定时对AOF文件重写，达到压缩的目的<br>11.redis的集群怎么同步的数据的。</p>
<p>12.知道哪些redis的优化操作。<br>    1.让键名保持简短,可读性更强<br>    2.对key最好都带上过期时间<br>    3.避免超大容量key<br>13.Reids的主从复制机制原理。<br>    分为两种复制:<br>    从节点使用psync()来实现同步<br>       1.全量同步<br>           1.主服务器收到同步请求，执行bgsave命令，同时使用缓冲区暂存命令<br>           2.bgsave完成后将rdb文件发送给从服务器，从服务器收到RDB文件后，将数据保存到磁盘，然后加载到内存中<br>           3.然后主服务器再将缓冲区的命令发给从服务器，从服务器执行这些命令<br>        2.部分同步  主要用于节点丢失，做数据补发<br>            主从节点分别保存着一个数据偏移量，来验证数据的一致性<br>            从节点把自身偏移量发给主节点，主节点根据偏移量把挤压缓冲区中数据发送给从节点<br>14.Redis的线程模型是什么。<br>    多路复用IO<br>15.Redis的淘汰策略<br>    volatile-lru： 只对设置了过期时间的key进行LRU（默认值）<br>    noeviction ： 永不过期，返回错误</p>
<pre><code>volatile-random：过期key随机删除
 volatile-ttl ： 删除即将过期的

  allkeys-random： 全量Key中随机删除
  allkeys-lru ：   全量Key进行LRU</code></pre><p>16.热点Key问题<br>    1.使用互斥锁来实现，只允许一个线程构建缓存<br>    2.key”永久”存储<br>    3.对热点问题先一步业务分析，可以将数据分布到集群中<br>17.Redis 高效问题<br>     1.绝大部分请求是纯粹的内存操作（非常快速）<br>     2.采用单线程,避免了不必要的上下文切换和竞争条件<br>     3.非阻塞IO<br>15.Memcache的原理，哪些数据适合放在缓存中。</p>
<p>16.redis和memcached 的内存管理的区别。<br>17.简述本地缓存和分布式缓存和优缺点。<br>   本地缓存<br>    优点：性能高，没有网络消耗<br>    缺点：没有持久化机制，难保持数据一致性，存储数量小，受GC影响<br>   分布式缓存：<br>   优点：数据集中，易于维护数据一致性，中间件可以实现对内存的统一管理，便于水平扩容<br>   缺点: 有网络以及序列化和反序列化消耗，一般以来中间件来处理</p>
<p>18.本地缓存在并发使用时的注意事项。</p>
<p>19.Ehcache原理 有几种<br>   1 FIFO，先进先出<br>   2 LFU，最少被使用，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。<br>   3 LRU，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>分布式</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2020/04/18/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>1.分布式事务<br>  2PC<br>    第一阶段是预提交<br>       要求所有参与者提交事务<br>       反馈提交结果<br>    第二阶段要求事务提交或者回滚<br>    如果全是OK，就提交事务<br>    有一个不OK就回滚<br>    <a id="more"></a><br>  3PC<br>     第一阶段询问参与者能否提交<br>     第二阶段所有参与者反馈能提交，就发出提交事务请求<br>     第三阶段 反馈提交结果，完成事务提交<br>   XA协议比较简单，但是有单点问题，由于阻塞所以不能很好的支持并发，很依赖事务管理器<br>    TCC<br>    Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）<br>    Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。<br>    Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</p>
<p>2.CAP理论<br>Consistency(一致性), 数据一致更新，所有数据变动都是同步的<br>Availability(可用性):系统提供的服务对于用户的请求，总是能在“有限的时间”内“返回结果”<br>P (分区容错性)：服务在遇到任何网络分区故障时，仍然能提供一致性和可用性的服务</p>
<p>3.BASE理论<br>　BASE是Basically Available(基本可用)，Soft state(软状态)，Eventually consistent(最终一致性)这三个短语的简写。<br>可以简单BASE理论是对CAP权衡后演化而来的结果<br>基本可用：分布式系统在出现不可预知的故障时，允许损失部分可用性(响应时间延长/部分非核心功能不可用，有点降级的意思)<br>软状态：允许数据存在中间状态，并且认为该中间状态的存在不会影响系统的整体可用性<br>最终一致性：系统中所有副本的数据，在经过一段时间后，最终能达到一致</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>开源框架</title>
    <url>/2020/04/18/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>1.Spring 核心模块</p>
<p>core 提供依赖注入和Bean管理功能，主要组件是 BeanFactory，<br>ORM Spring支持多种ORM框架，简化了数据库操作。<br>web 建立于Context模块之上，提供了一个适合于Web应用的上下文,同时还提供和其他web服务的支持<br>Context 扩展了BeanFactory的概念，增加了对国际化、事件传播，<br>AOP 为Spring容器管理的对象提供了对面向切面编程的支持；<br>DAO 该层封装了对数据库的访问，并且处理了其抛出的错误消息，同时还基于AOP模块提供了事务管理；<br>MVC：是一个全功能的构建 Web 应用程序的 MVC 实现，容纳了大量视图技术，如 JSP、Velocity、POI等；</p>
<a id="more"></a>
<p>2.Spring IOC<br>  控制反转，是一种设计思想，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。<br>    1.调用refresh()方法开始<br>    2.Rosource资源定位  resourceLoader<br>    3.资源载入 将指定用户的Bean表示成BeanDefiontione<br>    4.注册  将bean注册到一个map容器中</p>
<p>3.Bean的生命周期:<br>1.实例化bean<br>2.设置依赖注入<br>3.注入Auto接口<br>4.初始化Bean<br>5.使用<br>6.卸载<br><a href="https://www.zhihu.com/question/38597960" target="_blank" rel="noopener">https://www.zhihu.com/question/38597960</a></p>
<p>加载第三方的Bean @Configuration  +@Bean</p>
<p>spring事务传播属性:</p>
<p>Propagation.REQUIRED（required）：支持当前事务，如果当前有事务， 那么加入事务， 如果当前没有事务则新建一个(默认情况)<br>Propagation.NOT_SUPPORTED（not_supported) ： 以非事务方式执行操作，如果当前存在事务就把当前事务挂起，执行完后恢复事务（忽略当前事务）；<br>Propagation.SUPPORTS (supports) ：如果当前有事务则加入，如果没有则不用事务。<br>Propagation.MANDATORY (mandatory) ：支持当前事务，如果当前没有事务，则抛出异常。（当前必须有事务）<br>PROPAGATION_NEVER (never) ：以非事务方式执行，如果当前存在事务，则抛出异常。（当前必须不能有事务）<br>Propagation.REQUIRES_NEW (requires_new) ：支持当前事务，如果当前有事务，则挂起当前事务，然后新创建一个事务，如果当前没有事务，则自己创建一个事务。<br>Propagation.NESTED (nested 嵌套事务) ：如果当前存在事务，则嵌套在当前事务中。如果当前没有事务，则新建一个事务自己执行（和required一样）。嵌套的事务使用保存点作为回滚点，当内部事务回滚时不会影响外部事物的提交；但是外部回滚会把内部事务一起回滚回去。（这个和新建一个事务的区别）<br> 当前事务？</p>
<p>3.Spring AOP<br>   面向切面编程<br>    连接点：能够被拦截的地方<br>    切点：每个方法都可以称之为连接点，我们具体定位到某一个方法就成为切点。<br>    通知:前置、后置、返回、异常、环绕</p>
<p>  AOP使用:权限、日志、缓存<br>3.AOP实现方式三种：1.JDK动态代理 2.Cglib字节码 3.Aspet增强<br>  JDK动态代理和Cglib字节码区别<br>     动态代理<br>       1.通过实现 InvocationHandler 接口创建自己的调用处理器<br>       2.通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类<br>       3.通过反射机制获得动态代理类的构造函数<br>       4.通过构造方法将自定义的处理类当参数放入。<br>       5.通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入<br>     Cglib<br>      1.通过asm字节码生成框架生成代理类Class的二进制字节码<br>      2.通过Class.forName加载二进制字节码，生成Class对象<br>      3.通过反射机制获取实例构造，并初始化代理类对象<br>    1.动态代理需要实现接口，cglib需要继承<br>    2.动态代理通过类加载和反射来生成代理类,cglib是基于字节码来生成</p>
<p>4.依赖注入方式<br>    setget注入<br>    构造器注入<br>    注解注入<br>    接口注入 有侵入性<br>5.相关注解<br>@Autowired默认按类型装配 假如有相同的Bean，再按名称匹配<br>@Qualifier名称装配<br>@Resource 是JDK1.6支持的注解，默认按照名称进行装配<br>6.Spring的事物传播属性<br>  七中事务传播机制 REQUIRED, REQUIRES_NEW等等</p>
<p>5.SpringMvc 原理<br>    (1) Http请求：客户端请求提交到DispatcherServlet。<br>    (2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。<br>    (3) 调用处理器：DispatcherServlet将请求提交到Controller。<br>    (4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。<br>    (6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。<br>    (8) Http响应：视图负责将结果显示到客户端。</p>
<p>6.Servlet 干了什么<br>   DispatcherServlet  继承  FrameworkServlet  继承 HttpServletBean  并且它也继承自 HttpServlet<br>   HttpServletBean 主要做一些初始化的工作，将web.xml中配置的参数设置到Servlet中。比如servlet标签的子标签init-param标签中配置的参数。<br>   FrameworkServlet   初始化webApplicationContext，建立springMVC 上下文，并于父类spring上下文关联<br>   DispatcherServlet  初始化各个功能的实现类。比如异常处理、视图处理、请求映射处理等。<br>7.Mybaties 原理<br>   1.通过configuration解析config.xml配置文件和mapper.xml映射文件，映射文件可以使用xml方式或者注解方式<br>   2.然后由configuration获得sqlsessionfactory对象，再由sqlsessionfactory获得sqlsession数据库访问会话对象，<br>   3.通过JDK动态代理生成Mapper文件的代理类<br>8.Mybaties 二级缓存和更新策略<br>    一级缓存是SqlSession级别的，如果同一个SqlSession中使用了相同的SQL，只有第一次会查询数据库，假如有了DML语句，将会一级缓存<br>    二级缓存是跨SqlSession，不同的SqlSession两次执行相同的namespace下的sql语句，<br>    LRU默认<br>    FIFO<br>    软引用<br>    弱引用<br>    #{}是经过预编译的,是安全的。<br>    而${}是未经过预编译的,仅仅是取变量的值,是非安全的,存在SQL注入。</p>
<p>9.Dubbo的原理，<br>   1.消费方调用本地服务<br>   2.本地服务将参数方法等信息组装成网络传输的消息体<br>   3.本地服务找到服务地址，并将消息发给服务端<br>   4.服务端本地服务收到消息后进行解码<br>   5.服务端本地服务调用本地服务，本地服务做业务处理，然后再把结果转给服务端<br>   6.服务端就结果打包成网络传输的消息体<br>   7.客户端收到消息进行转码然后给消费方<br>10.数据怎么流转的，怎么实现集群，负载均衡，服务注册，和发现，重试转发，快速失败的策略是怎样的</p>
<ol>
<li><p>dubbo服务治理、服务降级以及重试<br>1.调用链路自动生成<br>2.服务访问压力以及时长统计 主要看全链路，TP50/TP90/TP99<br>3.服务分层、调用链路失败监控报警、服务监控<br>2.服务降级<br>假如两个服务调用多次失败，就走降级备用逻辑给用户响应/<br>3.服务重试00<br>①失败重试<br>consumer调用provider失败了，比如provider出现了异常，这时候就要进行重试。<br>②服务超时<br>设置超时时间<br>重试：6次，超时：200ms</p>
<p>dubbo提供了负载均衡:1.Random 2.随机，按权重设置随机概率。 3. 轮循，按公约后的权重设置轮循比率。4.最少活跃 5.一致性hash<br>快速失败策略：</p>
</li>
</ol>
<p>   //添加事务注解<br>    //1.使用 propagation 指定事务的传播行为, 即当前的事务方法被另外一个事务方法调用时<br>    //如何使用事务, 默认取值为 REQUIRED, 即使用调用方法的事务<br>    //REQUIRES_NEW: 事务自己的事务, 调用的事务方法的事务被挂起.<br>    //2.使用 isolation 指定事务的隔离级别, 最常用的取值为 READ_COMMITTED<br>    //3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚. 也可以通过对应的<br>    //属性进行设置. 通常情况下去默认值即可.<br>    //4.使用 readOnly 指定事务是否为只读. 表示这个事务只读取数据但不更新数据,<br>    //这样可以帮助数据库引擎优化事务. 若真的事一个只读取数据库值的方法, 应设置 readOnly=true<br>    //5.使用 timeout 指定强制回滚之前事务可以占用的时间.<br>    @Transactional(propagation=Propagation.REQUIRES_NEW,<br>            isolation=Isolation.READ_COMMITTED,<br>            noRollbackFor={UserAccountException.class},<br>            rollbackFor = IOException.class,<br>            readOnly=false,<br>            timeout=3)   传播属性、隔离级别、是否只读、超时时间<br>    @Override<br>    public void purchase(String username, String isbn) {}<br>11.zk原理<br>12.什么是paxos算法， 什么是zab协议。<br>    zab协议采用的paxos算法， leader节点失效，迅速从从节点中重新选出一个替代者<br>   Paxos算法的目标就是让他们按照少数服从多数的方式，最终达成一致意见。</p>
<p>13.Zookeeper watch机制原理。</p>
<p>14.ngnix原理<br>   ngnix反向代理和负载均衡<br>    轮询<br>    加权轮询<br>    源地址哈希法<br>    随机<br>    最小连接数法<br>15.ngnix限流<br>  limit_req_zone：通过“漏桶”算法限制每个 IP 发起的请求频率。<br>limit_conn_zone：限制每个 IP 发起的连接数。<br>正向和反向代理</p>
<p>16.简单讲讲tomcat结构，以及其类加载器流程，线程模型等。<br>    tomcat就是一个server ，一个server对应多个service，一个service对应对应多个Connector 和 Container，其中Connector 主要负责对外交流，Container 主要处理 Connector 接受的请求<br>17.tomcat如何调优，涉及哪些参数<br>   1.提高JVM栈内存Increase JVM heap memory<br>      Xms – 指定初始化时化的栈内存<br>     -Xms – 指定初始化时化的栈内存<br>      -Xmx – 指定最大栈内存<br>    2. – 线程池设置<br>       maxThreads<br>常用限流方法；<br>   1.计数器法<br>       一分钟只能有100个请求<br>         缺点：没法处理临界值问题<br>   1.漏桶算法<br>       消费速率一定，但进量会受到限制，座椅用过流程整形<br>   2.令牌桶算法<br>      往桶里添加令牌，请求来了，从桶里申请令牌，如果有，则去消费，没有就排队或者丢弃请求</p>
<p>降级：技术降级、服务开关</p>
<p>过滤器和拦截器的区别：</p>
<pre><code>  1、拦截器是基于java的反射机制的，而过滤器是基于函数回调 
  2、拦截器不依赖与servlet容器，过滤器依赖与servlet容器
  3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用 
  4、拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次 
拦截器 ：是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。

 web.xml 的加载顺序是：</code></pre><p>context-param -&gt; listener -&gt; filter -&gt; servlet ，而同个类型之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。</p>
<p>netty 相关<br>   1.Netty 的线程模型<br>      1、Reactor单线程模型<br>           1.作为 NIO 服务端，接收客户端的 TCP 连接；<br>           2.作为 NIO 客户端，向服务端发起 TCP 连接；<br>           3.读取通信对端的请求或者应答消息；<br>           4.向通信对端发送消息请求或者应答消息。<br>      2、Reactor多线程模型<br>            1.有专门一个 NIO 线程 Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求；<br>            2.网络 IO 操作 - 读、写等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO   线程负责消息的读取、解码、编码和发送；<br>            4.1个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，防止发生并发操作问题。</p>
<pre><code>  3、主从多线程模型

        Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。   
2.TCP 粘包/拆包的原因及解决方法
   因为是走TCP/IP 协议，一个完整的包会被拆成多个包发送，
    粘包和半包
    粘包就是数据包多了一截，半包就是少了一部分
解决办法：
  1.消息定长
  2.包尾增加结束标识
3.Netty空转问题
   定义一个当前时间currentTimeNanos，接着计算出一个执行最少需要的时间timeoutMillis。每次对selectCnt做++操作。
  若在某个周期内连续发生N次空轮询，则触发了epoll死循环bug，就重建Selector   默认512
4.</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/04/18/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>1.基础<br>  1.1数组为啥能[i]取值？<br>      数组（Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据<br>  1.2 基本数据类型<br>      byte、short、int、double、long、float、boolean、char<br>  1.3.String的HashCode<br>      String 是char[]数组组成<br>      String 的 char 数组的数字每次乘以 31 再叠加最后返回   hashcode=char[i]* 31+hashcode;<br>      31 有个很好的性能,可以得到更好的性能  31 * i == (i &lt;&lt; 5） - i<br>  1.4 hashcode和equals实现？这么做有何优劣。<br>        equals和HashCode 都是object的方法，equals需要重写，假如没重写和==效果相同，<br>        1.重写了equals()没有重写HashCode()  会导致equals相等的两个对象，hashcode()不等<br>        2.重写了HashCode() 没有重写eauals（） 其实这个和== 效果相同  没有比较作用<br>  1.5 error和exception的区别，CheckedException，RuntimeException的区别。<br>     error和exception的均继承Throwable  Error（错误）是系统中的错误，程序是不能改变的和处理的 异常是程序可能出现的问题<br>     runtimeException不用显示try()catch() 空指针 数据越界 类型转换 IO异常 数据库异常</p>
  <a id="more"></a>
<p>  1.6 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。<br>        Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)<br>  1.7 Java8的新特性。<br>     Lambda表达式和函数式接口<br>     Stream流<br>     Optional 对Null的处理   去避免if-else<br>     Date/Time Api的一些优化</p>
<p>  1.8 反射<br>       『反射』就是指程序在运行时能够动态的获取到一个类的类型信息的一种操作。<br>       有三种方式:1.类.class  2.getClass 3.class.forName()</p>
<p>2.集合<br>    2.1 List<br>        2.1.1 ArrayList<br>         add() 在数组尾部增加元素，但是数组增加或者删除中间元素会引起元素移动<br>         扩容() 原容量右移两位+原容量 相当于扩了1.5倍，扩容完成由Array.copyof()和System.copyOf()将原数组拷贝到新数组上<br>         实现了RandomAcces()接口，同时因为是数组，所以支持随机访问<br>         因为for循环删除会导致元素移动，然后会删除不干净<br>        iterator()中三个方法  hasNext()  next(),remove() 操作完成会有指针的变化</p>
<pre><code>    2.1.2 LinkList
    底层是链表实现，链表查询改变前后节点引用，不涉及元素移动，所以插入快，查找慢

    以上均为不安全的集合

    2.1.4 CopyOnWriteList
        ArrayList线程安全版本，适合多读少写场景，每当有写发生时，会将当前List产生一个新的副本，再上边操作，然后再该改变引用。    



2.2 Map
   2.2.1 HashMap
          1.7:  hashCode&amp;(table.length-1)
          1.8:  hashCode^(hashCode&gt;&gt;&gt;16)
            为啥数组长度是2的整次幂？长度减少1 正好相当于一个低位掩码，与运算高位归0，保留低位，且比取模有更高的效率
          右移16位，正好是位数一半，混合原始hash码的高低位，以此加大低位随机性
          put()
          1.先判断table是不是空的，如果是扩容
          2.根据hashCode找桶，找到桶，如果节点为空，直接存入
          3.如果不为空，equals(),然后覆盖
          4.如果是树，插入树节点
          5.如果是链表，遍历链表插入，深度如果到8，转为树
          6.判断是不是到达负载值
          get()
          跟put()相反
          resize() 
          扩容条件
             HashMap.size &gt;= Capacity*LoadFactor&amp;&amp; 节点索引值是空的
                当前数据存储的数量（即size()）大小必须大于等于阈值；当前加入的数据是否发生了hash冲突。
             transfer()将旧数组元素迁往新数组
            1.7 重新机算hash，旧链表迁新链表，如果在新表位置相同，则元素会倒置，1.8不会

        jdk1.8之前并发操作hashmap时为什么会有死循环的问题    
            假如两个操作都触发扩容操作，扩容里边的transfer()方法，会造成节点的相互引用，然后再get的到造成一直遍历，

      红黑树：
   1、要么为一颗空树，要么就是一颗具有如下特性的二叉树。
   2、它的左子树和右子树都是平衡二叉树。
   3、它的左子树和右子树的深度差的绝对值不超过1。
引申：
Hash求法：
1.直接寻址法
2.数组分析法
3.平方取中法
4.除留取余法
5.随机数法
Hash冲突处理：
    1.开放地址法 以发生冲突的哈希地址为输入，通过某种哈希冲突函数得到一个新的空闲的哈希地址的方法。
    2.创建一个公共溢出区
    3.再哈希法
    4.拉链法

   2.2.2 HashSet
        底层是HashMap  所有key存在数组上  value统一都是PRESENT  存进来后调用equals()和HashCode()方法判断
   2.2.3 treeMap
       key必须实现comprable接口，
   2.2.4 LinkedHashMap了解基本原理、哪两种有序、如何用它实现LRU
         其实 LinkedHashMap 几乎和 HashMap 一样：
          其中多了三个参数，头节点、尾节点和顺序布尔值，维护了一个链表，每当有操作时候，会把操作节点移动到尾节点上，慢慢的头节点就是最少使用的节点的，当缓存满时，就可移除
          两种顺序，插入顺序和访问顺序

   2.2.5 ConcurrentHashMap
           1.7 分段锁 由数组结构锁定段 因为初始为16个，所以并发也就16 
         1.8 去掉分段所，CAS+Volatile+Native方法锁定树或者数组头节点
fail-fast和fail-safe
fail-fast机制在遍历一个集合时，当集合结构被修改，会抛出Concurrent Modification Exception。
    fail-fast会在以下两种情况下抛出ConcurrentModificationException
     （1）单线程环境
         集合被创建后，在遍历它的过程中修改了结构。
         注意 remove()方法会让expectModcount和modcount 相等，所以是不会抛出这个异常。
      （2）多线程环境
         当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。

    fail-safe任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出ConcurrentModificationException
    fail-safe机制有两个问题
    （1）需要复制集合，产生大量的无效对象，开销大
    （2）无法保证读取的数据是目前原始数据结构中的数据。
实现原理：
   迭代器内部会维护一个标识，当集合结构改变，标识会被修改，而迭代器每次的hasNext()和next()方法都会检查该&quot;mode&quot;是否被改变，当检测到被修改时，抛出Concurrent Modification Exception

QUEUE
LinkedBlockingQueue的容量是没有上限的（说的不准确，在不指定时容量为Integer.MAX_VALUE，不要然的话在put时怎么会受阻呢），但是也可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。

 ArrayBlockingQueue在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队 列，此队列按 FIFO（先进先出）原则对元素进行排序。

 PriorityBlockingQueue是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。

 最后，DelayQueue（基于PriorityQueue来实现的）是一个存放Delayed 元素的无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且poll将返回null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于或等于零的值时，则出现期满，poll就以移除这个元素了。此队列不允许使用 null 元素。

1.无界队列 LinkedBlockingQueue FIFO
2.有界队列 ArrayBlockingQueue   FIFO排序  可以实现公平性 （其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）
3.优先级队列 
4.延迟队列</code></pre><p>JAVA中注解<br>3.关键字<br>  final<br>  static<br>  private<br>  Iterator<br>     关于Iterator主要有三个方法：hasNext()、next()、remove()<br>      hasNext:没有指针下移操作，只是判断是否存在下一个元素<br>      next：指针下移，返回该指针所指向的元素<br>     remove：删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素</p>
<p>4.内存模型<br>   JVM内存模型 主要目标就是定义了程序中各个变量的访问规则，也就是虚拟机中变量存储到内存和从内存取出变量的底层细节</p>
<p>   重排序 指令重排是指在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序.<br>   内存屏障是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作<br>   happen-before<br>   单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。<br>   锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。<br>   volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。<br>   happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。<br>5.字节码<br>     cofe babe 是 魔数<br>     接着两位是 次版本号<br>     继续两位是 主版本号<br>6.类加载<br>    6.1  类载流程<br>      加载—验证—准备—解析— 初始化—-使用—-卸载<br>      简单说说你了解的类加载器，<br>      启动类加载器(加载\lib)，拓展类加载器(\lib\ext)，应用类加载器(calssPath)，自定义类加载器<br>      双亲委派是什么？<br>      就是说儿子收到类加载请求，自己不干，先找父类加载，父类能加载就返回，不能加载自己再来加载<br>      为什么要双亲委派？<br>      避免类的重复加载，核心API不容易被篡改</p>
<pre><code>6.2  如何破坏双亲委派？         

6.3  为什么要破坏双亲委派？
 JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口
双亲委派模型并不是一个强制性约束，而是java设计者推荐给开发者的类加载器的实现方式，在一定条件下，为了完成某些操作，可以“破坏”模型。     JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载,所以引入了线程上下文，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。
6.4  ClassNotFoundException和NoClassDefFoundErr区别？
  1.文件未被找到   2.在程序利用反射时候，就可能碰到这种异常，一般因为找不到对应类
6.5  如何解决ClassNotFound？

6.6 修改类加载策略要复写哪个方法？</code></pre><p>7.并发<br>  7.1  Synchronized<br>       1. 普通同步方法，锁是当前实例对象<br>       2. 静态同步方法，锁是当前类的class对象<br>       3. 同步方法块，锁是括号里面的对象<br>       原理：Synchronized 同步代码块 monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出<br>       同步方法则是加了一个ACC_SYNCHRONIZED标识，在JVM进行方法调用时，发现调用的方法被ACC_SYNCHRONIZED修饰，则会先尝试获得锁。<br>      synchronized的底层是使用操作系统的mutexlock实现的，Java线程映射到操作系统层面，无论唤醒还是阻塞都需要操作系统支持，从用户态转为核心态，所以是个重量级操作<br>  7.2  Lock<br>        7.2.1 乐观锁和悲观锁<br>            悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。<br>            乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。<br>  7.3  并发容器<br>         CopyOnWriteList<br>         ConcurrentHashMap</p>
<pre><code>为什么java.util.concurrent 包里没有并发的ArrayList实现？
   很难去开发一个通用并且没有并发瓶颈的线程安全的List。
     拿contains() 这样一个操作来说，当你进行搜索的时候如何避免锁住整个list？</code></pre><p>  7.4  volatile的原理<br>        修饰关键字，保证了可见性,不能保证原子性，使用Volatile关键字，汇编上会在变量前边增加Lock前缀，然后会导致两种效果:<br>           1.当前处理器缓存行会写回到主存，2.写回操作会让其他CPU上该数据无效化<br>  7.5  Lock与Synchronized的区别 。</p>
<p>  7.6  自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁。<br>        自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。<br>        偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。<br>        轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>        可重入锁 在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁<br>        公平锁是指多个线程按照申请锁的顺序来获取锁。</p>
<p>  7.7 Java对象头　　<br>        Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针），如果是数组还有数组长度<br>        　markWord 存储对象自身的运行时数据，主要存储HashCode、分代年龄和锁标记位等消息<br>  7.8  原子类<br>       7.8.1 CAS+volatile+Unsafe类获取内存上的值  循环比较 如果相同则成功，不同则继续尝试<br>       7.8.2 产生ABA问题－－－－2.JDK增加了类AtomicStampedReferenc，这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。<br>       循环时间长开销大—–》CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销<br>  7.9  AQS<br>        7.9.1 重要的字段和方法<br>            private volatile int state;<br>            其中包含了5个状态：<br>            1.CANCELLED：线程被取消。（非负值）<br>            -1.SIGNAL：等待触发，只有当前节点的前驱节点状态为SIGNAL，当前节点的线程才可以被挂起。<br>            -2.CONDITION：等待条件状态。<br>            -3.PROPAGATE：状态需要向后传播。<br>            0：普通的同步器初始化为0。<br>                 字段为同步状态，其中 state &gt; 0 为有锁状态，每次加锁就在原有 state 基础上加 1，即代表当前持有锁的线程加了 state 次锁，反之解锁时每次减一，当 statte = 0 为无锁状态；<br>         7.9.2 AQS 的结构<br>            用 volatile 修饰的整数类型的 state 状态，用于表示同步状态，提供 getState 和 setState 来操作同步状态；<br>            提供了一个 FIFO 等待队列，实现线程间的竞争和等待，这是 AQS 的核心；<br>            AQS 内部提供了各种基于 CAS 原子操作方法，如 compareAndSetState 方法，并且提供了锁操作的acquire和release方法。<br>            排他锁:<br>            1.当一个线程来了，设置state为1，如果成功，返回，如果不成功，通过CAS操作将其放入队列尾节点上<br>            2.在队列中时，如果前置节点是头节点，在队列中尝试获取资源，获取失败后判断是否真正需要进入阻塞状态，如果是将阻塞线程，直到被唤醒，并返回中断状态。不断循环，直到获取到资源或者进入阻塞状态等待被唤醒<br>            3.获取资源失败后判断线程是否需要真正进入阻塞，只有在前驱节点waitStatus值为SIGNAL，当前节点的线程才需要进入阻塞<br>            4.在这里线程进入了阻塞，调用 LockSupport.park(this)阻塞线程</p>
<pre><code>    共享锁    1.调用tryRelease(),如果成功，唤醒后继节点，唤醒后，设置节点状态为0，允许失败，一般来说需要唤醒的就是下一个节点，但是下一个节点可能是null，或者其状态是取消状态，所以从tail开始先前查找，一直找到状态正常的节点。
    2.  //唤醒线程
    LockSupport.unpark(s.thread);

附：https://brightloong.github.io/2018/06/21/Java%E5%90%8C%E6%AD%A5%E5%99%A8%E2%80%94%E2%80%94AQS%E5%AD%A6%E4%B9%A0/</code></pre><p>  7.10 线程池<br>        7.10.1 线程池的种类<br>           定长，缓存，单例和调度<br>        7.10.2 线程池作用<br>           实现线程管理，线程复用和控制并发数<br>        7.10.3 线程池核心参数<br>            coreSize,MaxSize,time,工作队列，线程工厂(为线程设置名字，异常处理等)，Handler(任务提交失败处理策略)<br>        7.10.4 线程池的状态<br>               Running 运行状态<br>               shutdown 不再接受任务，但会继续处理任务<br>               stop 不再接受任务，也会中断所有任务<br>               tidying 任务执行完成，会进行回调<br>               terminated 回调完成</p>
<pre><code>7.10.5 线程池工作流程
       1.提交任务，如果小于coreSize,就增加worker，
       2.继续提交，大于coreSize小于MaxSize,就放入队列，
       3.继续提交，如果队列满了，就开始创建非核心线程处理任务，
       4.还继续提交，线程到达maxsize，就开始执行拒绝策略
7.10.6 线程池实现复用原理
       线程池中有个volatile修饰的值来记录线程池中线程池状态和线程数
       其中高三位记录线程池状态，低29位记录线程数，
       复用原理：
         1.线程池中任务执行者是worker(),worker保持着while()循环
         2.如果从队列中没有拿到任务就阻塞，拿到任务就执行提交任务中的run()
         3.当大于CoreSize()时候就创建非核心线程来执行任务，完事了线程执行完了阻塞然后等待超时
7.10.7 为啥不推荐使用Executors?
        ExecutorS创建线程池很多参数都是设定好的，而且有些值的设定(队列长度位Inter.max()),会导致OOM。
7.10.8 执行ececute()和Submit()区别
        ececute()提交不需要返回值的线程
        submit()提交需要返回值的线程，返回结果future对象，可用get()来获取结果，但该操作会阻塞，推荐使用带时间的get()
7.10.9 根据什么来确定线程池核心线程数?
        根据业务来分，机算密集型 线程数就是CPU个数+1
                       IO密集型   线程数就是n*CPU个数
7.10.10 线程池执行的拒绝策略有哪些
           AbortPolicy策略：直接抛出异常 线程池默认的拒绝策略；该策略会直接抛出异常，任务不会被执行 
         CallerRunsPolicy策略：只用调用者所在线程来运行任务
         DiscardOldestPolicy策略：丢弃队列中即将执行的任务，并执行当前任务 
         DiscardPolicy策略：不处理，直接丢弃  适用于博客，无关业务的场景</code></pre><p>  7.11并发辅助类 （Semaphore、CountDownLatch、CyclicBarrier、Exchanger）</p>
<p>  7.12 导致线程死锁的原因？怎么解除线程死锁。<br>          线程之间各自资源占有，等待对方释放，循环等待，造成死锁<br>        JDK提供了两种方式来给我们检测：<br>         JconsoleJDK自带的图形化界面工具，使用JDK给我们的的工具JConsole<br>         jps 找到进程  然后jstack  查看进程中具体情况<br>         Jstack是JDK自带的命令行工具，主要用于线程Dump分析。<br>       定位到锁位置后<br>        1.缩减同步代码块范围，最好仅操作共享变量时+<br>        才加锁<br>        2.以固定的顺序加锁<br>        3.采用带定时的锁<br>  7.13 适用ThreadLocal时要注意什么？比如说内存泄漏?<br>         采用的Map形式，为线程保留单独的副本，key为弱引用，但value是强引用，所以会造成OOM<br>8.JVM相关<br>   8.1 JVM的内存结构。<br>        线程私有<br>          1.程序计数器(唯一没有OOM的地儿)<br>             作用:1.字节码解释器通过程序计数器来依次读取指令<br>                  2.多线程情况下，记录线程切换切换前的位置<br>          2.虚拟机栈(会出现栈溢出和OOM)<br>             存储编译器可知对象的数据类型和对象引用<br>          3.本地方法栈(会出现栈溢出和OOM)<br>        线程共有:<br>          4.Java堆 线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象<br>          5.方法区(后边被移除，变成元空间) 线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。<br>          6.直接内存<br>          7.运行时常量池（后边移入JAVA堆中）<br>   8.2 什么情况下会发生栈内存溢出。<br>       栈溢出就是方法执行是创建的栈帧超过了栈的深度，一般方法递归就会出现这种<br>   8.3 Eden和Survivor比例:<br>        Eden:Survivor0:Survivor1=8:1:1<br>   8.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。<br>        1.对于GC实现来说,由于它们在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。如果说收集整个GC堆耗时太长，那不如只收集其中的一部分？,而且对象大部分生命周期很短，但少量就会活很长时间，所以针对不同的特性来处理<br>        2.Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p>
<p>   8.5 对象如何晋升到老年代，说说你知道的几种主要的JVM参数。<br>        1.大对象直接进入老年代<br>        2.对象在Eden出生并经过第一次Minor GC后仍然存活，并能被Survivor容纳的话，将被移动到Survivor区，并将对象年龄设为1<br>         对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁。当年龄增长到一定值（默认16）后，对象被晋升到老年代。</p>
<p>   8.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。<br>        新生代:Serial收集器、复制算法  单线程收集器  或造成Stop-the-world<br>               ParNew 收集器、Serial收集器的多线程版本，它也是一个新生代收集器。 复制算法<br>               Parallel Scavenge 收集器 是一个并行的多线程新生代收集器，它也使用复制算法。 可控制吞吐量<br>        老年代：Serial Old收集器、 它同样是一个单线程收集器，使用“标记-整理”（Mark-Compact）算法。<br>                Parallel Old收集器、 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法<br>                CMS收集器、 一种以获取最短回收停顿时间为目标的收集器   标记-清除<br>                     初始标记<br>                     并发标记<br>                     重新标记<br>                     并发清除<br>                优点：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。<br>                缺点：1.对CPU资源非常敏感        CMS默认启动的回收线程数是（CPU数量+3）/4，CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大<br>                      2.无法处理浮动垃圾（Floating Garbage）<br>                         由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生<br>                      3.标记-清除算法导致的空间碎片<br>                          会造成很多空间碎片，可能导致空间很大，大对象却没地儿分配<br>                G1收集器<br>                    初始标记<br>                    并发标记<br>                    最终标记<br>                    筛选回收<br>                     G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。<br>   8.7 垃圾回收算法的实现原理。<br>       标记-清除<br>          先对所有需要回收的对象进行标记，标记完成统一回收。<br>           缺点:1.效率比较低<br>                2.会造成大量空间碎片，可能导致对象因为找到连续内存，出发新一轮GC<br>       标记-整理<br>        和标记-清除算法类似，但不清除对象，只是把对象移动到一端，然后清理掉另一端的垃圾<br>       复制算法<br>         将内存分为两块，一块用完了，就把存活对象复制到另外一块上，然后清除这块儿垃圾<br>         缺点就是，使用内存减少一半<br>       分代算法<br>   8.8 当出现了内存溢出，你怎么排错。<br>         内存溢出有三种情况：<br>           1.有可能是内存分配确实过小，而正常业务使用了大量内存<br>           2.某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽<br>           3.某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接<br>        1.直接查看日志，对堆栈信息<br>        2.步骤一、使用jps：jps -l<br>                  使用ps：ps aux | grep tomat<br>          步骤二、jstat”监视虚拟机各种运行状态信息。<br>                 jstat -gcutil 20954 1000<br>          步骤三、转存dump文件<br>                 jmap -histo:live 20954<br>                 使用Mat<br>           堆外内存使用GDB或者pmap来分析</p>
<pre><code>3. 查发生了OOM的进程  执行top -c ，显示进程运行信息列表,键入M (大写m)，进程按照内存使用排序
   确认是不是内存本身就分配过小 jmap -heap
   找到最耗内存的对象  jmap -histo:live 2820 | more </code></pre><p>   8.9 怎么打出线程栈信息<br>       $jstack –l 23561 &gt;&gt; xxx.dump<br>   8.11 cpu 100%怎样定位<br>        步骤一、找到最耗CPU的进程<br>          执行top -c ，显示进程运行信息列表,键入P (大写p)，进程按照CPU使用率排序<br>        步骤二、找到最耗CPU的线程<br>          top -Hp 线程Pid ，显示一个进程的线程运行信息列表，键入P (大写p)，线程按照CPU使用率排序<br>          需要使用printf 命令 将10进制转成16进制<br>        步骤三：查看堆栈，找到线程在干嘛<br>          jstack 线程Pid<br>    应用突然反应很慢，如何定位问题？<br>     1.top看看CPU、内存和IO的情况<br>     2.看看整个链路问题<br>     3.看看代码上是不是有什么持有内存</p>
<pre><code>FullGC比较频繁，如何处理
   特征：1.CPU很容易飙升到100%，statck查看大部分都是垃圾线程
         2.jstat查看虚拟机情况，可以看到FullGC次数多
     1.先按照CPu100%处理找到出问题的线程
     2.使用eclipse的mat工具来分析</code></pre><p>   8.11 判断对象存活<br>        1.引用计数法 —-&gt;无法解决重复引用问题<br>        2.可达性分析算法 从GCRoots出发，向下搜索，搜索所经过的路程称之为引用链，无法被引用的对象即为死亡对象<br>    8.12 GCRoots都包含哪些<br>         1.虚拟机栈中引用对象<br>         2.本地方法栈中的对象<br>         3.方法区中静态属性引用的对象<br>         4.方法区常量引用的对象</p>
<pre><code>8.13 常用的JVM命令
    jps 显示所有虚拟机进程
    jstat 用于收集虚拟机各项运行数据
    jinfo 显示虚拟机配置信息
    jmap 生成虚拟机快照
    jhat 用于分析dump文件
    jstack  可以查看或导出 Java 应用程序中线程堆栈信息。

    VisualVM
    eclipse的mat工具
8.14 JVM几种引用
强、软、弱、虚
    -Xms1024m    初始堆大小
    -Xmx1024m    最大堆大小
   -Xmn500m    年轻代大小
   -Xss1024k    单个线程栈</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>1.Mysql索引类型<br>  1.1 按类型分<br>       Hash索引  只支持精确查找，不支持范围查找，不支持排序  下·<br>       空间索引 只有MyISAM引擎支持，并且支持的<br>       全文索引 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。<br>       Btree索引<br>   1.2 聚集索引和非聚集索引<br>   聚簇索引:聚簇索引是指索引的结构和排列规则是和实际数据的存储结构和排列规则是一样的，一张表只能有一个，<br>   非聚簇索引:也就二级索引 非主键索引的叶子节点内容是主键的值。</p>
<a id="more"></a>

<p>2.Mysql优化<br>  设计数据库时：数据库表字段的设计，存储引擎选择<br>  利用好MySQL自身提供的功能，如索引等<br>  横向扩展：MySQL集群、负载均衡、读写分离、分库分表<br>   SQL语句的优化<br>   数据返回等等是否都是必须</p>
<p>3.Mysql B树怎么查询</p>
<p>   建立索引注意点:<br>    1.选择唯一性索引<br>    2.为经常需要排序、分组和联合操作的字段建立索引<br>    3.为常作为查询条件的字段建立索引<br>    4.限制索引的数目<br>    5.尽量使用数据量少的索引<br>    6. 最左前缀匹配原则，非常重要的原则。</p>
<p>4.Mysql一个查询流程<br>    分为两层：server层和引擎层<br>  查询语句的执行流程如下：<br>  连接器（负责跟客户端建立连接、获取权限、维持和管理连接）——&gt;查询缓存——-&gt;分析器(词法分析、语法分析)——&gt;优化器(判断使用什么索引、或者join表时表的连接顺序,虽然结果相同，但效率不同)——&gt;执行器(先查询看看有没有对表的操作权限，然后再调引擎层的接口)<br>   连接器（负责跟客户端建立连接、获取权限、维持和管理连接）—》查询缓存—》分析器(词法分析、语法分析)—》优化器—》权限校验—》执行器—》引擎<br>  更新语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log(prepare 状态—》binlog—》redo log(commit状态)<br>5.Mysql最左原则</p>
<p>6.Mysql主从同步<br>   三个线程：<br>   dump线程为每一个slave创建的<br>   I/O线程、SQL线程活动在每一个slave上<br>    主从同步流程:<br>      1.Slave 服务器上执行start slave，开启主从复制开关，主服务器上会把sql都写入binLog中<br>      2.slave 会先通过Master权限验证，并请求Master指定位置之后的binLog内容<br>      3.Master把根据slave I/O线程发来信息，把后继的日志发给Slave<br>      4.salve把Master发来的binlog 日志写入中继日志末端，并将新的 binlog 文件名和位置记录到 master-info 文件中，<br>      5.SalveSql 线程检测到中继日志变化，将中继日志中的内容解析成Sql,在自己服务器上执行一边<br>    主从复制模式<br>       1.异步模式<br>       2.半自动模式 主节点只需要接收到其中一台从节点的返回信息，就会commit；<br>       3.全同步 主节点和从节点全部执行了commit并确认才会向客户端返回成功。<br>    主从复制有三种方式:<br>      1.基于Sql语句的复制<br>      2.基于行的复制<br>      3.混合模式</p>
<p>7.Mysql两种日志<br>    1.redo log<br>        引擎层的,是物理日志，记录的是“在某个数据页上做了什么修改”<br>        redo log 是循环写的,先写日志，再写磁盘,空间固定会用完</p>
<pre><code>2.bin log
  server层
  binlog 是逻辑日志，记录的是这个语句的原始逻辑
  binlog 是追加写入，文件写道一定大小，会切换下一个

为啥会有两种日志呢？
  redo是引擎层的，其他公司开发的，而binlog是server层的，redo打开事务，binlog写完再提交事务，两端提交，保证数据一致性</code></pre><p>8.Mysql5.7新特性<br>   1.JSON支持<br>   2.安全性 root用户密码是随机的，默认连接走的SSL加密<br>9.分库分表(实现)<br>    分库:<br>    1.取模<br>    2.顺序放入1–9999的放入1号库<br>    分表：<br>       1.水平拆分 单表数量太大，将表分割<br>       2.竖直拆分  单表业务耦合太多，将表拆成几个表<br>    带来的问题：<br>      1.事务问题<br>        由应用程序控制，保证最终一致性<br>         可以做事务补偿机制<br>            1.回调地址 2.消息通知<br>      2.跨节点Join的问题<br>          1.做一些反范式化的设计<br>          2.由应用程序两次查询来处理<br>      3.跨节点的count,order by,group by以及聚合函数问题<br>          这种需要全部数据，在节点排序后，在应用程序段进行合并<br>      4.ID问题<br>          分库后ID不可重新<br>          1.UUID 不推荐 UUID比较长 会比较战内存空间  建立索引和基于索引查询比较费时<br>          2.Twitter的分布式自增ID算法Snowflake<br>             机器码+时间+自增序号<br>        使用中间件来做分库分表操作<br>            Mycat  shardingJDBC</p>
<p>10.脏读、幻读<br>   脏读 一个事务读到另外一个事务未提交的数据<br>   幻读 第一个事务查询N条  另外一个事务对数据做了新增或者删除操作，当第一个事务再次来查询时候 ，记录条数结果不一样，出现幻行</p>
<p>   不可重复度 在一个事务内两次相同查询读到的数据内容是不一样的，因此称为是不可重复读。</p>
<p>  读已提交和可重复读区别<br>    读已提交  读到人家已经提交的数据，但是一个事务内两次查询，查询结果不一样<br>    可重复读  一个事务内多次读取，内容都是一样，但是可能会出现幻读</p>
<p>11.简单的数据结构<br>栈、队列、链表、数组、哈希表、树<br>12.事务特性<br>   原子性、一致性、隔离性、持久性<br>13.事务的隔离级别<br>   读未提交 全都有<br>   读已提交 没有脏读<br>   可重复读 没有脏读和不可重复读<br>   序列化<br>14.Mysql的乐观和悲观锁<br>     select * from table lock in share mode  ——-乐观锁<br>     select * from table for update   ——悲观锁<br>15.查询explain<br>    explain Sql<br>    – 结果：<br>  id:选择标识符<br>  select_type:表示查询的类型。 （简单查询,联合查询,子查询）<br>  table:输出结果集的表<br>  partitions:匹配的分区<br>  type:表示表的连接类型 从最好到最差的连接类型为system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL<br>  possible_keys:表示查询时，可能使用的索引<br>  key:表示实际使用的索引<br>  key_len:索引字段的长度<br>  ref:列与索引的比较<br>  rows:扫描出的行数(估算的行数)<br>  filtered:按表条件过滤的行百分比<br>  Extra:执行情况的描述和说明<br>16.慢查询<br>    slow_query_log</p>
<p>17.红黑树为啥那样设计？<br>  首先聊一下二叉搜索树，主要特点是左节点比根节点小，右节点比根节点大，并且左右子树都是二叉搜索树。缺点是在极端情况下，比如插入都是有序的，就会出现退化的情况有序序列树退化成链表，此时，要想让树的节点平均分布就需要平衡树了，红黑树就是平衡树的一种（平衡二叉搜索树）。然后，一棵树的查询性能取决于树的高度，红黑树让树尽可能平衡，就是为了降低树的高度。<br>18.什么是B树？<br>   B树是一种平衡多路搜索树，他的每个节点可以拥大于等于2个子节点，M路的B树最多能拥有M个子节点，一个节点中有 m 个子节点则存在 m-1 个记录，记录按照递增次序进行排列，叶节点都在同一层上。B树之所以多路(也就是每个节点上可存多个记录）是为了降低高度，路数越多，树高度越低，查询性能也高。但也不能是无限的，否则就退化成有序数组了。<br>19.什么是B+树？<br>    B+树是在B树基础上进行改造，他的数据都在叶子结点，同时叶子结点之间还加了指针形成一个链表。<br>20.为什么用B+树存储索引而不用B树？<br>   这也是和业务场景相关的，一般去数据库查询数据，不一定只选一条，很多时候会选多条数据，在查多条情况下，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。<br>21.为什么用B+树做索引？<br>   主要还是为了减少磁盘中机械臂的运动，增加定位的效率</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>问题记录</title>
    <url>/2020/04/18/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>1.为啥要去重写HashCode和Equals?<br>两个对象怎么去判断是不是同一个对象，<br>   假如重写了equals() 没重写hashcode()   对象相等 hashcode不同<br>   假如重写了hashcode() 没重写equals()     对象就不会相等</p>
<p>2.Object常用的方法？<br>    wait()  notify()  notifyAll()   equals()  hashcode() getClass()   toString()</p>
<a id="more"></a>
<p>3.红黑树的特性<br>   平衡二叉树<br>4.方法区和堆栈作用是啥<br>    栈就是存的时方法的数据类型和对象引用，方法区存储类信息、常量、静态变量、即时编译器编译后的代码。<br>5.数组是存在哪的</p>
<p>6.LinkList和ArrayList使用场景？</p>
<p>8.队列有哪几种<br>  1.arrayBlockQueue 2.LinkBlockQueue  3. 优先级队列  4. 延时队列</p>
<p>9.HashMap扩容的原因是因为桶还是key?<br>     map扩容两个条件，map.size&gt;=负载值&amp;&amp;table[index]!=null<br>10.Java中引用有哪几种？<br>   强引用：无论内存是否足够，不会回收。<br>   软引用：内存不足时，回收该引用关联的对象。<br>   弱引用：垃圾回收时，无论内存是否足够，都会回收。<br>   虚引用：任何时候都可能被垃圾回收器回收。<br>11.Java中常用的锁有哪些？<br>    排它锁、共享锁、乐观锁、悲观锁、分段锁、自旋锁、公平锁、非公平锁、可重入锁等。<br>12.HashMap  Entry数组中包含有哪些属性</p>
<p>13.信号量的使用<br>    1.final Semaphore semp = new Semaphore(5);  先定义多少个并发<br>    2.semp.acquire();   获取许可<br>    3.semp.release();    释放许可<br>14.HashSet<br>     HashSet底层由HashMap实现<br>     HashSet的值存放于HashMap的key上<br>     HashMap的value统一为PRESENT<br>15.TreeMap<br>    数据+tree<br>     保证了顺序，输出时候按中序遍历<br>     put时候如果有相同的数据，替换，没有就插入新建，然后再平衡红黑树<br>     get时按二叉搜索树搜索</p>
<p>1.Mysql的主从复制有哪几种方式？<br>   1.基于Sql的复制<br>   2.基于行的复制<br>   3.混合模式</p>
<p>2.幻读和不可重复读的区别<br>   1.幻读指的是同一事务两次读写，读取的数据记录不一样<br>   2.不可重复读指的是读取的记录内容不一样<br>3.可重复读和读已提交的区别<br>   1.读已提交可能会造成幻读和不可重复度</p>
<p>4.字段重复度比较高  适合建索引吗？<br>    重复度比较高列不适合建索引， 非聚簇索引存储了对主键的引用，所以使用非聚集索引会造成大量的回表操作，性能低<br>5.使用in,Or会走索引吗？<br>   不走索引<br>6.is not  null会走索引吗？</p>
<p>7.最左前缀原则<br>  abc组合索引<br>  a 可以<br>  ab  可以<br>  ac可以<br>  abc 可以<br>  c,b,a 可以<br>  b,c不可以</p>
<p>1.Spring事务相关的一些知识点<br>  1.编程时和声明式<br>  2.@Transaction<br>  3.对事务相关的配置（配置传播属性，超时，隔离级别）</p>
<p>2.RequestParam和RequestBody<br>   @RequestParam接收的参数是来自requestHeader中，即请求头。通常用于GET请求，也可以使用POST delete等<br>      Content-Type:application/x-www-form-urlencoded，multipart/form-data<br>   解@RequestBody接收的参数是来自requestBody中，即请求体。可以将参数映射到实体类上<br>      Content-Type: application/json, application/xml等<br>3.怎么加载第三方的Bean<br>  @Configuration+@Bean</p>
<p>4.#和$的区别，项目中什么地儿用到了这两个？<br>     #{}是经过预编译的,是安全的。<br>    而${}是未经过预编译的,仅仅是取变量的值,是非安全的,存在SQL注入。<br>5.JMS和AMQP区别<br>    JMS 就是Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM-分布式系统的集成）的API。</p>
<p>6.服务的注册和发现原理</p>
<p>7.zuul怎么去做鉴权和路由</p>
<p>9.Redis中set底层结构<br>  intSet和HashTable</p>
<p>10.setnx Redis怎么实现的</p>
<p>11.数据库和缓存怎么去保持数据一致性<br>     数据开始写，最好实现双写，假如有数据更新，先删缓存，再更新数据库  </p>
<p>12.Redis底层怎么个结构</p>
<p>13.长短连接怎么弄的</p>
<p>1.单例模式中DCL<br> 双重检查加锁（Double Check Lock）的方法来避免每次调用getInstance()方法时都同步<br>  因为上边是使用了volatile指令  =<br>2.策略模式<br> 定义一个接口，然后有多种实现</p>
<p>1.zookeeper的注册发现<br>2.zookeeper的节点数据<br>3.zookeeper的分布式锁实现<br>4.dubbo的负载、限流、降级等等<br>5.Java 中Nio 原理<br>6.netty的相关的知识点<br>7.Redis数据类型深入的一些知识点<br>8.JVM调优相关的一些知识点<br>9.Spring 的init和destory<br>10.Spring相关的知识点<br>11.Mysql索引相关的知识点<br>12.可重入锁原理和AQS相关的<br>13.Redis中增减操作<br>14.秒杀场景需要梳理下<br>15.对称加密算法和非对称加密算法</p>
<p>16.想想现在项目上还有可以改进的地方<br>    1.项目试算模块性能不是很好<br>17.Spring-quartz 因为是随着应用启动，假如应用部署多台，同一时刻相同的任务就会有多个，且被处理多次  xxl-job原理</p>
<p>18.Jvm常调整的参数：<br>1.堆的最大最小内存<br>2.新生代、老年代的最大最小内存<br>3.每个线程的栈内存<br>4.新生代晋升年龄</p>
<p>19.垃圾回收算法<br>    19.1 标记-清除算法<br>          标记效率低下，而且会造成空间碎片<br>    19.2 标记-整理算法<br>          1.存活对象多时，效率比较低，而且需要一半的内存，同时还需要一定的内存担保<br>    19.3  复制算法<br>           需要牺牲一半的内存<br>20.常用的内存分析工具<br>   jconsole，VisualVM，Memory Analyzer、</p>
<p>21 JDK原生中用到了哪些设计模式</p>
<p>22  Spring中事务是怎么实现的？</p>
<p>23 分布式锁提交释放掉,怎么处理</p>
<p>24 算法时间复杂度  O(1) 常数阶  对数阶  线性阶  平方阶   立方阶  </p>
<p>1.SpringAop原理<br>   JDK动态代理和Cglib动态代理<br>2.dubbo流程，ZK</p>
<p>3.数据库上的CAS<br>4.zk几种节点类型<br>  持久目录节点，持久顺序节点，临时目录节点，临时顺序节点<br>5.zk协议<br>6.sync和可重入锁</p>
<p>7.dubbo中的协议<br>  默认单一长连接<br>8.Mysql索引的存储方式</p>
<p>10.Mysql中索引和数据怎么存储<br>  存储B+树的叶子节点<br>11.动态代理和静态代理区别<br>12.Controller中定义一个可读可写的全局变量<br>13.AQS<br>14.netty反应模型<br>   单线程  一个线程处理所有任务(接受请求，编码解码，响应)<br>   多线程  一个线程负责监听客户端，一个Nio线程池负责处理<br>   主从多线程  boss线程池负责接受请求，把socket包装成NioSocketChannel放入work线程池,work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。  </p>
<p>15.zk中的同步怎么做的 CP</p>
<p>16.zk怎么去实现分布式锁<br>17.数据库事务隔离级别 和会出现的问题</p>
<p>18.MVCC<br>   多版本并发控制<br>19.查看是否使用索引<br>   explain sql<br>      id、表名、连接类型、可能使用的索引、实际使用的索引、索引的长度、扫描的行数<br>20.SpringAOP是怎么使用的<br>21.秒杀怎么去扣库存<br>22.<br>23.fork/join<br>24.beanFactory和applicontent<br>  BeanFactory接口提供了管理对象的能努力，ApplicationContext接口是BeanFactory的子接口，它在BeanFactory的IoC的基础上提供了AOP特性、消息（国际化）处理、事件发布和应用层的其他特性，如WebApplicationContext在web应用中的使用。</p>
<p>1.为啥要去重写HashCode和Equals?<br>两个对象怎么去判断是不是同一个对象，<br>   假如重写了equals() 没重写hashcode()   对象相等 hashcode不同<br>   假如重写了hashcode() 没重写equals()     对象就不会相等</p>
<p>2.Object常用的方法？<br>    wait()  notify()  notifyAll()   equals()  hashcode() getClass()   toString()</p>
<p>3.红黑树的特性<br>   平衡二叉树<br>4.方法区和堆栈作用是啥<br>    栈就是存的时方法的数据类型和对象引用，方法区存储类信息、常量、静态变量、即时编译器编译后的代码。<br>5.数组是存在哪的</p>
<p>6.LinkList和ArrayList使用场景？</p>
<p>8.队列有哪几种<br>  1.arrayBlockQueue 2.LinkBlockQueue  3. 优先级队列  4. 延时队列</p>
<p>9.HashMap扩容的原因是因为桶还是key?<br>     map扩容两个条件，map.size&gt;=负载值&amp;&amp;table[index]!=null<br>10.Java中引用有哪几种？<br>   强引用：无论内存是否足够，不会回收。<br>   软引用：内存不足时，回收该引用关联的对象。<br>   弱引用：垃圾回收时，无论内存是否足够，都会回收。<br>   虚引用：任何时候都可能被垃圾回收器回收。<br>11.Java中常用的锁有哪些？<br>    排它锁、共享锁、乐观锁、悲观锁、分段锁、自旋锁、公平锁、非公平锁、可重入锁等。<br>12.HashMap  Entry数组中包含有哪些属性</p>
<p>13.信号量的使用<br>    1.final Semaphore semp = new Semaphore(5);  先定义多少个并发<br>  2.semp.acquire();   获取许可<br>  3.semp.release();    释放许可<br>14.HashSet<br>     HashSet底层由HashMap实现<br>     HashSet的值存放于HashMap的key上<br>     HashMap的value统一为PRESENT<br>15.TreeMap<br>    数据+tree<br>   保证了顺序，输出时候按中序遍历<br>   put时候如果有相同的数据，替换，没有就插入新建，然后再平衡红黑树<br>   get时按二叉搜索树搜索</p>
<p>1.Mysql的主从复制有哪几种方式？<br>   1.基于Sql的复制<br>   2.基于行的复制<br>   3.混合模式</p>
<p>2.幻读和不可重复读的区别<br>   1.幻读指的是同一事务两次读写，读取的数据记录不一样<br>   2.不可重复读指的是读取的记录内容不一样<br>3.可重复读和读已提交的区别<br>   1.读已提交可能会造成幻读和不可重复度</p>
<p>4.字段重复度比较高  适合建索引吗？<br>    重复度比较高列不适合建索引， 非聚簇索引存储了对主键的引用，所以使用非聚集索引会造成大量的回表操作，性能低<br>5.使用in,Or会走索引吗？<br>   不走索引<br>6.is not  null会走索引吗？</p>
<p>7.最左前缀原则<br>  abc组合索引<br>  a 可以<br>  ab  可以<br>  ac可以<br>  abc 可以<br>  c,b,a 可以<br>  b,c不可以</p>
<p>1.Spring事务相关的一些知识点<br>  1.编程时和声明式<br>  2.@Transaction<br>  3.对事务相关的配置（配置传播属性，超时，隔离级别）</p>
<p>2.RequestParam和RequestBody<br>   @RequestParam接收的参数是来自requestHeader中，即请求头。通常用于GET请求，也可以使用POST delete等<br>      Content-Type:application/x-www-form-urlencoded，multipart/form-data<br>   解@RequestBody接收的参数是来自requestBody中，即请求体。可以将参数映射到实体类上<br>      Content-Type: application/json, application/xml等<br>3.怎么加载第三方的Bean<br>  @Configuration+@Bean</p>
<p>4.#和$的区别，项目中什么地儿用到了这两个？<br>  #{}是经过预编译的,是安全的。<br>  而${}是未经过预编译的,仅仅是取变量的值,是非安全的,存在SQL注入。<br>5.JMS和AMQP区别<br>  JMS 就是Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM-分布式系统的集成）的API。</p>
<p>6.服务的注册和发现原理</p>
<p>7.zuul怎么去做鉴权和路由</p>
<p>9.Redis中set底层结构<br>  intSet和HashTable</p>
<p>10.setnx Redis怎么实现的</p>
<p>11.数据库和缓存怎么去保持数据一致性<br>     数据开始写，最好实现双写，假如有数据更新，先删缓存，再更新数据库  </p>
<p>12.Redis底层怎么个结构</p>
<p>13.长短连接怎么弄的</p>
<p>1.单例模式中DCL<br> 双重检查加锁（Double Check Lock）的方法来避免每次调用getInstance()方法时都同步<br>  因为上边是使用了volatile指令  避免了指令重拍<br>2.策略模式<br> 定义一个接口，然后有多种实现</p>
<p>1.zookeeper的注册发现<br>2.zookeeper的节点数据<br>3.zookeeper的分布式锁实现<br>4.dubbo的负载、限流、降级等等<br>5.Java 中Nio 原理<br>6.netty的相关的知识点<br>7.Redis数据类型深入的一些知识点<br>8.JVM调优相关的一些知识点<br>9.Spring 的init和destory<br>10.Spring相关的知识点<br>11.Mysql索引相关的知识点<br>12.可重入锁原理和AQS相关的<br>13.Redis中增减操作<br>14.秒杀场景需要梳理下<br>15.对称加密算法和非对称加密算法</p>
<p>16.想想现在项目上还有可以改进的地方<br>    1.项目试算模块性能不是很好<br>17.Spring-quartz 因为是随着应用启动，假如应用部署多台，同一时刻相同的任务就会有多个，且被处理多次  xxl-job原理</p>
<p>18.Jvm常调整的参数：<br>1.堆的最大最小内存<br>2.新生代、老年代的最大最小内存<br>3.每个线程的栈内存<br>4.新生代晋升年龄</p>
<p>19.垃圾回收算法<br>    19.1 标记-清除算法<br>          标记效率低下，而且会造成空间碎片<br>    19.2 标记-整理算法<br>          1.存活对象多时，效率比较低，而且需要一半的内存，同时还需要一定的内存担保<br>    19.3  复制算法<br>           需要牺牲一半的内存<br>20.常用的内存分析工具<br>   jconsole，VisualVM，Memory Analyzer</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>1.设计模式六大原则<br>  1.单一原则<br>  2.里氏代换<br>  3.依赖倒置<br>  4.接口隔离<br>  5.迪米特法则<br>  6.合成复用</p>
<a id="more"></a>
<p>常用设计模式<br>  1.单例模式<br>     线程池，连接池<br>  2.工厂模式<br>  3.简单工厂模式<br>  4.抽象工厂模式<br>  5.建造者模式<br>  6.代理模式<br>     静态代理<br>     动态代理<br>       1.通过实现 InvocationHandler 接口创建自己的调用处理器<br>       2.通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类<br>       3.通过反射机制获得动态代理类的构造函数<br>       4.通过构造方法将自定义的处理类当参数放入。<br>       5.通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入<br>     Cglib<br>      1.通过asm字节码生成框架生成代理类Class的二进制字节码<br>      2.通过Class.forName加载二进制字节码，生成Class对象<br>      3.通过反射机制获取实例构造，并初始化代理类对象<br>    1.动态代理需要实现接口，cglib需要继承<br>    2.动态代理通过类加载和反射来生成代理类,cglib是基于字节码来生成</p>
<p>  7.适配器模式<br>     原类和适配器类转换(电脑接口)<br>  8.模板方法模式<br>     JdbcTemplet？<br>  9.观察者模式<br>      存在一对多关系(发布订阅)<br>  10.策略模式<br>       针对不同行为提供不同的实现(不同的算法)<br>  11.装饰模式<br>      不改变其结构，给其增加功能(橡皮鸭加飞机引擎)</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
